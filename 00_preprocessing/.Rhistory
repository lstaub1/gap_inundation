ctg = las_catalogs$Mont2020a,
processed_dir = "F:/MASTERS/THESIS/data/Processed/Mont2020a",
tile_size = 1000,
buffer = 30,
crs_target = "EPSG:2248"
)
#### Potential New workflow -----
filter_tiles <- function(chunk, output_dir, buffer, remove_duplicates = TRUE) {
las <- readLAS(chunk)
if (is.null(las) || npoints(las) == 0) {
message("⚠️ Empty tile found, skipping")
return(NULL)
}
message("📦 Processing tile with ", npoints(las), " points")
# Optionally remove exact duplicate points
if (remove_duplicates) {
las@data <- distinct(las@data)
}
# Classify ground
las <- classify_ground(las, algorithm = csf())
# Keep ground and surface (last return) points
las <- lasfilter(las, Classification == 2 | ReturnNumber == NumberOfReturns)
# Trim buffer — keep only the core area
core <- raster::extent(chunk)  # extent from chunk (includes buffer)
core@xmin <- core@xmin + buffer
core@xmax <- core@xmax - buffer
core@ymin <- core@ymin + buffer
core@ymax <- core@ymax - buffer
las <- lasclipRectangle(las, core@xmin, core@ymin, core@xmax, core@ymax)
# Output filename based on chunk's core origin
tile_name <- paste0("tile_", chunk@header$X[1], "_", chunk@header$Y[1], ".laz")
out_file <- file.path(output_dir, tile_name)
writeLAS(las, out_file)
message("✅ Processed tile written to: ", out_file)
return(out_file)
}
retile <- function(ctg, processed_dir, tile_size, buffer, crs_target) {
if (!inherits(ctg, "LAScatalog")) stop("Input must be a LAScatalog object.")
if (!is.null(crs_target)) {
projection(ctg) <- crs_target
}
# Configure tiling
opt_chunk_size(ctg) <- tile_size
opt_chunk_buffer(ctg) <- buffer
opt_output_files(ctg) <- ""  # Don’t write by default, we control writing
opt_progress(ctg) <- TRUE
opt_filter(ctg) <- "-drop_withheld"
dir_create(processed_dir)
catalog_apply(ctg, function(chunk, ...) {
filter_tiles(chunk, processed_dir, buffer)
})
message("🎉 All tiles processed and saved in: ", processed_dir)
}
retile(
ctg = las_catalogs$Mont2020a,
processed_dir = "F:/MASTERS/THESIS/data/Processed/Mont2020a",
tile_size = 1000,
buffer = 30,
crs_target = "EPSG:2248"
)
?packageName::lasfilter
library(lidR)
?lidR::lasfilter
??lasfilter
#### Potential New workflow -----
filter_tiles <- function(chunk, output_dir, buffer, remove_duplicates = TRUE) {
las <- readLAS(chunk)
if (is.null(las) || npoints(las) == 0) {
message("⚠️ Empty tile found, skipping")
return(NULL)
}
message("📦 Processing tile with ", npoints(las), " points")
# Optionally remove exact duplicate points
if (remove_duplicates) {
las@data <- distinct(las@data)
}
# Classify ground
las <- classify_ground(las, algorithm = csf())
# Keep ground and surface (last return) points
las <- las[las@data$Classification == 2 | las@data$ReturnNumber == las@data$NumberOfReturns, ]
# Trim buffer — keep only the core area
core <- raster::extent(chunk)  # extent from chunk (includes buffer)
core@xmin <- core@xmin + buffer
core@xmax <- core@xmax - buffer
core@ymin <- core@ymin + buffer
core@ymax <- core@ymax - buffer
las <- lasclipRectangle(las, core@xmin, core@ymin, core@xmax, core@ymax)
# Output filename based on chunk's core origin
tile_name <- paste0("tile_", chunk@header$X[1], "_", chunk@header$Y[1], ".laz")
out_file <- file.path(output_dir, tile_name)
writeLAS(las, out_file)
message("✅ Processed tile written to: ", out_file)
return(out_file)
}
retile <- function(ctg, processed_dir, tile_size, buffer, crs_target) {
if (!inherits(ctg, "LAScatalog")) stop("Input must be a LAScatalog object.")
if (!is.null(crs_target)) {
projection(ctg) <- crs_target
}
# Configure tiling
opt_chunk_size(ctg) <- tile_size
opt_chunk_buffer(ctg) <- buffer
opt_output_files(ctg) <- ""  # Don’t write by default, we control writing
opt_progress(ctg) <- TRUE
opt_filter(ctg) <- "-drop_withheld"
dir_create(processed_dir)
catalog_apply(ctg, function(chunk, ...) {
filter_tiles(chunk, processed_dir, buffer)
})
message("🎉 All tiles processed and saved in: ", processed_dir)
}
retile(
ctg = las_catalogs$Mont2020a,
processed_dir = "F:/MASTERS/THESIS/data/Processed/Mont2020a",
tile_size = 1000,
buffer = 30,
crs_target = "EPSG:2248"
)
#### Potential New workflow -----
filter_tiles <- function(chunk, output_dir, buffer, remove_duplicates = TRUE) {
las <- readLAS(chunk)
if (is.null(las) || npoints(las) == 0) {
message("⚠️ Empty tile found, skipping")
return(NULL)
}
message("📦 Processing tile with ", npoints(las), " points")
# Optionally remove exact duplicate points
if (remove_duplicates) {
las@data <- distinct(las@data)
}
# Classify ground
las <- classify_ground(las, algorithm = csf())
# Keep ground and surface (last return) points
las <- las[las@data$Classification == 2 | las@data$ReturnNumber == las@data$NumberOfReturns, ]
# Trim buffer — keep only the core area
core <- ext(chunk)  # extent from chunk (includes buffer)
core@xmin <- core@xmin + buffer
core@xmax <- core@xmax - buffer
core@ymin <- core@ymin + buffer
core@ymax <- core@ymax - buffer
las <- lasclipRectangle(las, core@xmin, core@ymin, core@xmax, core@ymax)
# Output filename based on chunk's core origin
tile_name <- paste0("tile_", chunk@header$X[1], "_", chunk@header$Y[1], ".laz")
out_file <- file.path(output_dir, tile_name)
writeLAS(las, out_file)
message("✅ Processed tile written to: ", out_file)
return(out_file)
}
retile <- function(ctg, processed_dir, tile_size, buffer, crs_target) {
if (!inherits(ctg, "LAScatalog")) stop("Input must be a LAScatalog object.")
if (!is.null(crs_target)) {
projection(ctg) <- crs_target
}
# Configure tiling
opt_chunk_size(ctg) <- tile_size
opt_chunk_buffer(ctg) <- buffer
opt_output_files(ctg) <- ""  # Don’t write by default, we control writing
opt_progress(ctg) <- TRUE
opt_filter(ctg) <- "-drop_withheld"
dir_create(processed_dir)
catalog_apply(ctg, function(chunk, ...) {
filter_tiles(chunk, processed_dir, buffer)
})
message("🎉 All tiles processed and saved in: ", processed_dir)
}
retile(
ctg = las_catalogs$Mont2020a,
processed_dir = "F:/MASTERS/THESIS/data/Processed/Mont2020a",
tile_size = 1000,
buffer = 30,
crs_target = "EPSG:2248"
)
#### Potential New workflow -----
filter_tiles <- function(chunk, output_dir, buffer, remove_duplicates = TRUE) {
las <- readLAS(chunk)
if (is.null(las) || npoints(las) == 0) {
message("⚠️ Empty tile found, skipping")
return(NULL)
}
message("📦 Processing tile with ", npoints(las), " points")
# Optionally remove exact duplicate points
if (remove_duplicates) {
las@data <- distinct(las@data)
}
# Classify ground
las <- classify_ground(las, algorithm = csf())
# Keep ground and surface (last return) points
las <- las[las@data$Classification == 2 | las@data$ReturnNumber == las@data$NumberOfReturns, ]
# Trim buffer — keep only the core area
core <- ext(las)  # Get extent using terra
core[1] <- core[1] + buffer  # xmin
core[2] <- core[2] - buffer  # xmax
core[3] <- core[3] + buffer  # ymin
core[4] <- core[4] - buffer  # ymax
# Clip the LAS object to the new extent
las <- lasclipRectangle(las, core[1], core[3], core[2], core[4])
# Output filename based on chunk's core origin
tile_name <- paste0("tile_", chunk@header$X[1], "_", chunk@header$Y[1], ".laz")
out_file <- file.path(output_dir, tile_name)
writeLAS(las, out_file)
message("✅ Processed tile written to: ", out_file)
return(out_file)
}
retile <- function(ctg, processed_dir, tile_size, buffer, crs_target) {
if (!inherits(ctg, "LAScatalog")) stop("Input must be a LAScatalog object.")
if (!is.null(crs_target)) {
projection(ctg) <- crs_target
}
# Configure tiling
opt_chunk_size(ctg) <- tile_size
opt_chunk_buffer(ctg) <- buffer
opt_output_files(ctg) <- ""  # Don’t write by default, we control writing
opt_progress(ctg) <- TRUE
opt_filter(ctg) <- "-drop_withheld"
dir_create(processed_dir)
catalog_apply(ctg, function(chunk, ...) {
filter_tiles(chunk, processed_dir, buffer)
})
message("🎉 All tiles processed and saved in: ", processed_dir)
}
retile(
ctg = las_catalogs$Mont2020a,
processed_dir = "F:/MASTERS/THESIS/data/Processed/Mont2020a",
tile_size = 1000,
buffer = 30,
crs_target = "EPSG:2248"
)
#### Potential New workflow -----
filter_tiles <- function(chunk, output_dir, buffer, remove_duplicates = TRUE) {
las <- readLAS(chunk)
if (is.null(las) || npoints(las) == 0) {
message("⚠️ Empty tile found, skipping")
return(NULL)
}
message("📦 Processing tile with ", npoints(las), " points")
# Optionally remove exact duplicate points
if (remove_duplicates) {
las@data <- distinct(las@data)
}
# Classify ground
las <- classify_ground(las, algorithm = csf())
# Keep ground and surface (last return) points
las <- las[las@data$Classification == 2 | las@data$ReturnNumber == las@data$NumberOfReturns, ]
# Trim buffer — keep only the core area
core <- ext(las)  # Get extent using terra
core[1] <- core[1] + buffer  # xmin
core[2] <- core[2] - buffer  # xmax
core[3] <- core[3] + buffer  # ymin
core[4] <- core[4] - buffer  # ymax
# Clip the LAS object to the new extent
las <- lasclip(las, core[1], core[3], core[2], core[4])
# Output filename based on chunk's core origin
tile_name <- paste0("tile_", chunk@header$X[1], "_", chunk@header$Y[1], ".laz")
out_file <- file.path(output_dir, tile_name)
writeLAS(las, out_file)
message("✅ Processed tile written to: ", out_file)
return(out_file)
}
retile <- function(ctg, processed_dir, tile_size, buffer, crs_target) {
if (!inherits(ctg, "LAScatalog")) stop("Input must be a LAScatalog object.")
if (!is.null(crs_target)) {
projection(ctg) <- crs_target
}
# Configure tiling
opt_chunk_size(ctg) <- tile_size
opt_chunk_buffer(ctg) <- buffer
opt_output_files(ctg) <- ""  # Don’t write by default, we control writing
opt_progress(ctg) <- TRUE
opt_filter(ctg) <- "-drop_withheld"
dir_create(processed_dir)
catalog_apply(ctg, function(chunk, ...) {
filter_tiles(chunk, processed_dir, buffer)
})
message("🎉 All tiles processed and saved in: ", processed_dir)
}
retile(
ctg = las_catalogs$Mont2020a,
processed_dir = "F:/MASTERS/THESIS/data/Processed/Mont2020a",
tile_size = 1000,
buffer = 30,
crs_target = "EPSG:2248"
)
#### Potential New workflow -----
filter_tiles <- function(chunk, output_dir, buffer, remove_duplicates = TRUE) {
las <- readLAS(chunk)
if (is.null(las) || npoints(las) == 0) {
message("⚠️ Empty tile found, skipping")
return(NULL)
}
message("📦 Processing tile with ", npoints(las), " points")
# Optionally remove exact duplicate points
if (remove_duplicates) {
las@data <- distinct(las@data)
}
# Classify ground
las <- classify_ground(las, algorithm = csf())
# Keep ground and surface (last return) points
las <- las[las@data$Classification == 2 | las@data$ReturnNumber == las@data$NumberOfReturns, ]
# Trim buffer — keep only the core area
core <- ext(las)  # Get extent using terra
core[1] <- core[1] + buffer  # xmin
core[2] <- core[2] - buffer  # xmax
core[3] <- core[3] + buffer  # ymin
core[4] <- core[4] - buffer  # ymax
# Clip the LAS object to the new extent
las <- clip_rectangle(las, core[1], core[3], core[2], core[4])
# Output filename based on chunk's core origin
tile_name <- paste0("tile_", chunk@header$X[1], "_", chunk@header$Y[1], ".laz")
out_file <- file.path(output_dir, tile_name)
writeLAS(las, out_file)
message("✅ Processed tile written to: ", out_file)
return(out_file)
}
retile <- function(ctg, processed_dir, tile_size, buffer, crs_target) {
if (!inherits(ctg, "LAScatalog")) stop("Input must be a LAScatalog object.")
if (!is.null(crs_target)) {
projection(ctg) <- crs_target
}
# Configure tiling
opt_chunk_size(ctg) <- tile_size
opt_chunk_buffer(ctg) <- buffer
opt_output_files(ctg) <- ""  # Don’t write by default, we control writing
opt_progress(ctg) <- TRUE
opt_filter(ctg) <- "-drop_withheld"
dir_create(processed_dir)
catalog_apply(ctg, function(chunk, ...) {
filter_tiles(chunk, processed_dir, buffer)
})
message("🎉 All tiles processed and saved in: ", processed_dir)
}
retile(
ctg = las_catalogs$Mont2020a,
processed_dir = "F:/MASTERS/THESIS/data/Processed/Mont2020a",
tile_size = 1000,
buffer = 30,
crs_target = "EPSG:2248"
)
#### Potential New workflow -----
filter_tiles <- function(chunk, output_dir, buffer, remove_duplicates = TRUE) {
las <- readLAS(chunk)
if (is.null(las) || npoints(las) == 0) {
message("⚠️ Empty tile found, skipping")
return(NULL)
}
message("📦 Processing tile with ", npoints(las), " points")
# Optionally remove exact duplicate points
if (remove_duplicates) {
las@data <- distinct(las@data)
}
# Classify ground
las <- classify_ground(las, algorithm = csf())
# Keep ground and surface (last return) points
las <- las[las@data$Classification == 2 | las@data$ReturnNumber == las@data$NumberOfReturns, ]
# Trim buffer — keep only the core area
core <- ext(las)  # Get extent using terra
core[1] <- core[1] + buffer  # xmin
core[2] <- core[2] - buffer  # xmax
core[3] <- core[3] + buffer  # ymin
core[4] <- core[4] - buffer  # ymax
# Clip the LAS object to the new extent
las <- clip_rectangle(las, core[1], core[3], core[2], core[4])
# Output filename based on chunk's core origin
tile_name <- paste0("tile_", las@header$X[1], "_", las@header$Y[1], ".laz")
out_file <- file.path(output_dir, tile_name)
writeLAS(las, out_file)
message("✅ Processed tile written to: ", out_file)
return(out_file)
}
retile <- function(ctg, processed_dir, tile_size, buffer, crs_target) {
if (!inherits(ctg, "LAScatalog")) stop("Input must be a LAScatalog object.")
if (!is.null(crs_target)) {
projection(ctg) <- crs_target
}
# Configure tiling
opt_chunk_size(ctg) <- tile_size
opt_chunk_buffer(ctg) <- buffer
opt_output_files(ctg) <- ""  # Don’t write by default, we control writing
opt_progress(ctg) <- TRUE
opt_filter(ctg) <- "-drop_withheld"
dir_create(processed_dir)
catalog_apply(ctg, function(chunk, ...) {
filter_tiles(chunk, processed_dir, buffer)
})
message("🎉 All tiles processed and saved in: ", processed_dir)
}
retile(
ctg = las_catalogs$Mont2020a,
processed_dir = "F:/MASTERS/THESIS/data/Processed/Mont2020a",
tile_size = 1000,
buffer = 30,
crs_target = "EPSG:2248"
)
# Set up Environment ----
library(pacman)
p_load(mapview, sf, ggplot2, mapview, lidR, terra, tidyterra, fs, archive, tools, abind, RCSF)
#Load Datasets
#Seneca duration hrcras raster as first example
hecras<- rast("F:\MASTERS\THESIS\MD_HECRAS\sen\IQ50\Duration (hrs).sen_ft.tif")
#Load Datasets
#Seneca duration hrcras raster as first example
hecras<- rast("F:/MASTERS/THESIS/MD_HECRAS/sen/IQ50/Duration (hrs).sen_ft.tif")
#Grab grid info
extent<- ext(hecras)
View(extent)
extent
resolution <- res(hecras)
crs_info <- crs(hecras)
resolution
crs_info
hecter<- rast("F:/MASTERS/THESIS/TerrainFiles/SenecaTerrainmo/SenecaTerrain/SenecaTerrain.tif")
#Grab grid info
extent<- ext(hecter)
resolution <- res(hecter) #4ft by 4ft!
crs_info <- crs(hecter) #
resolution
crs_info
vertical_crs_info <- crs(hecter, type = "vertical")
# Set up Environment ----
library(pacman)
p_load(mapview, sf, ggplot2, mapview, lidR, terra, tidyterra, fs, archive, tools, abind, RCSF)
#Load Datasets
#Seneca duration hrcras raster as first example
hecras<- rast("F:/MASTERS/THESIS/MD_HECRAS/sen/IQ50/Duration (hrs).sen_ft.tif")
hecter<- rast("F:/MASTERS/THESIS/TerrainFiles/SenecaTerrainmo/SenecaTerrain/SenecaTerrain.tif")
#Grab grid info
extent<- ext(hecras)
resolution <- res(hecras) #4ft by 4ft!
crs_info <- crs(hecras) #
#Grab grid info
extent<- ext(hecter)
resolution <- res(hecter) #1.8 by 1.8 ft?
crs_info <- crs(hecter)
View(hecras)
View(hecter)
crs_info
extent
resolution
# Named list of LAScatalogs
las_catalogs <- list(
Harf2013 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ34/clipped_chunk_1.laz"),
Harf2020 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Harf2020_BLK1/HARF2020_ft.laz"),
#Harf2020 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Harf2020_reprojected/HARF2020_ft.laz"),
Balt2015a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ30/clipped_chunk_1.laz"),
Balt2015b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ31/clipped_chunk_2.laz"),
How2011a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ26/clipped_chunk_2.laz"),
How2011b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ26/clipped_chunk_3.laz"),
How2018a  = readLAScatalog("F:/MASTERS/THESIS/data/Clip/How_2018_BLK_1/clipped_chunk_3.laz"),
How2018b  = readLAScatalog("F:/MASTERS/THESIS/data/Clip/How_2018_BLK_2/clipped_chunk_2.laz"),
Mont2020a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Montgomery_2020_BLK2/clipped_chunk_4.laz"),
Mont2020b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Montgomery_2020_BLK3/clipped_chunk_4.laz"),
Mont2018a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Mont_2018_BLK2/clipped_chunk_4.laz"),
Mont2018b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Mont_2018_BLK4/clipped_chunk_4.laz"),
Mont2013a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ12/clipped_chunk_3.laz"),
Mont2013b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ12/clipped_chunk_4.laz")
)
p_load(mapview, sf, ggplot2, mapview, lidR, terra, tidyterra, fS)
library(pacman)
p_load(mapview, sf, ggplot2, mapview, lidR, terra, tidyterra, fS)
# Named list of LAScatalogs
las_catalogs <- list(
Harf2013 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ34/clipped_chunk_1.laz"),
Harf2020 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Harf2020_BLK1/HARF2020_ft.laz"),
#Harf2020 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Harf2020_reprojected/HARF2020_ft.laz"),
Balt2015a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ30/clipped_chunk_1.laz"),
Balt2015b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ31/clipped_chunk_2.laz"),
How2011a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ26/clipped_chunk_2.laz"),
How2011b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ26/clipped_chunk_3.laz"),
How2018a  = readLAScatalog("F:/MASTERS/THESIS/data/Clip/How_2018_BLK_1/clipped_chunk_3.laz"),
How2018b  = readLAScatalog("F:/MASTERS/THESIS/data/Clip/How_2018_BLK_2/clipped_chunk_2.laz"),
Mont2020a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Montgomery_2020_BLK2/clipped_chunk_4.laz"),
Mont2020b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Montgomery_2020_BLK3/clipped_chunk_4.laz"),
Mont2018a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Mont_2018_BLK2/clipped_chunk_4.laz"),
Mont2018b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Mont_2018_BLK4/clipped_chunk_4.laz"),
Mont2013a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ12/clipped_chunk_3.laz"),
Mont2013b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ12/clipped_chunk_4.laz")
)
# Named list of LAScatalogs
las_catalogs <- list(
Harf2013 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ34/clipped_chunk_1.laz"),
Harf2020 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Harf2020_BLK1/clipped_chunk_1.laz"),
#Harf2020 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Harf2020_reprojected/HARF2020_ft.laz"),
Balt2015a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ30/clipped_chunk_1.laz"),
Balt2015b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ31/clipped_chunk_2.laz"),
How2011a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ26/clipped_chunk_2.laz"),
How2011b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ26/clipped_chunk_3.laz"),
How2018a  = readLAScatalog("F:/MASTERS/THESIS/data/Clip/How_2018_BLK_1/clipped_chunk_3.laz"),
How2018b  = readLAScatalog("F:/MASTERS/THESIS/data/Clip/How_2018_BLK_2/clipped_chunk_2.laz"),
Mont2020a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Montgomery_2020_BLK2/clipped_chunk_4.laz"),
Mont2020b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Montgomery_2020_BLK3/clipped_chunk_4.laz"),
Mont2018a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Mont_2018_BLK2/clipped_chunk_4.laz"),
Mont2018b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Mont_2018_BLK4/clipped_chunk_4.laz"),
Mont2013a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ12/clipped_chunk_3.laz"),
Mont2013b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ12/clipped_chunk_4.laz")
)
# Named list of LAScatalogs
las_catalogs <- list(
Harf2013 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ34/clipped_chunk_1.laz"),
Harf2020 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Harford_2020_BLK1/clipped_chunk_1.laz"),
#Harf2020 = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Harf2020_reprojected/HARF2020_ft.laz"),
Balt2015a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ30/clipped_chunk_1.laz"),
Balt2015b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ31/clipped_chunk_2.laz"),
How2011a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ26/clipped_chunk_2.laz"),
How2011b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ26/clipped_chunk_3.laz"),
How2018a  = readLAScatalog("F:/MASTERS/THESIS/data/Clip/How_2018_BLK_1/clipped_chunk_3.laz"),
How2018b  = readLAScatalog("F:/MASTERS/THESIS/data/Clip/How_2018_BLK_2/clipped_chunk_2.laz"),
Mont2020a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Montgomery_2020_BLK2/clipped_chunk_4.laz"),
Mont2020b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Montgomery_2020_BLK3/clipped_chunk_4.laz"),
Mont2018a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Mont_2018_BLK2/clipped_chunk_4.laz"),
Mont2018b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/Mont_2018_BLK4/clipped_chunk_4.laz"),
Mont2013a = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ12/clipped_chunk_3.laz"),
Mont2013b = readLAScatalog("F:/MASTERS/THESIS/data/Clip/LAZ12/clipped_chunk_4.laz")
)
