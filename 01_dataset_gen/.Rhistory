library(pacman)
p_load(lidR, terra, ggplot2)
## PATUXENT 2013----
# 1) Read the point cloud and DTM
las <- readLAS("F:/MASTERS/THESIS/2026_fresh/Clipped_Lidar/Montgomery2013a.laz")   # or .las
dtm <- rast("F:/MASTERS/THESIS/2026_fresh/DTM/PatuxentTerrain.tif")
#Grab las point density
summary(las)
# Ensure CRS matches
crs(dtm)
#Looks like the crs of the dtm is Maryland State Plane (SPCS) on NAD83(NSRS2007) in US survey feet, a Lambert Conformal Conic (2SP) projection. The matching EPSG is EPSG:3582 (“NAD83 (NSRS2007) / Maryland (ftUS)”). The DTM is in WTK format, which las does not accept.
crs(las)
#Looks like the crs of the dtm is Maryland State Plane (SPCS) on NAD83(NSRS2007) in US survey feet, a Lambert Conformal Conic (2SP) projection. The matching EPSG is EPSG:3582 (“NAD83 (NSRS2007) / Maryland (ftUS)”). The DTM is in WTK format, which las does not accept.
crs(las)
# Tell lidR the projection using EPSG (preferred for LAS headers)
projection(las) <- "EPSG:3582"
#Looks like the crs of the dtm is Maryland State Plane (SPCS) on NAD83(NSRS2007) in US survey feet, a Lambert Conformal Conic (2SP) projection. The matching EPSG is EPSG:3582 (“NAD83 (NSRS2007) / Maryland (ftUS)”). The DTM is in WTK format, which las does not accept.
crs(las)
# 2) Normalize heights above ground using the DTM
# This subtracts ground elevation from each point’s Z
las_n <- normalize_height(las, dtm)
#Check out height distribution of normalized data
summary(las_n@data$Z)
# Sample up to N points for plotting
set.seed(42)
N <- 5e6
z <- las_n$Z
z <- z[!is.na(z)]
z_sample <- if (length(z) > N) sample(z, N) else z
# Kernel Density plot
ggplot(data.frame(Z = z_sample), aes(Z)) +
geom_density(fill = "orange", alpha = 0.3) +
labs(title = "Density of heights", x = "Height above ground (m)", y = "Density") +
theme_minimal()
#Visualize normalized point cloud.
plot(las_n, color = "Z")
# (Optional) Remove obvious outliers and below-ground points
las_n <- filter_poi(las_n, Z >= 0 & Z <= 200)  # adjust max height for your forest
#Visually check for outliers
plot(las_n, color = "Z")
#double check tallest points
#We know that x and y are in ft, let's make sure z is in ft too.
#If 99.9th percentile ≈ 35, your Z is in meters.
#If 99.9th percentile ≈ 125, your Z is in feet.
quantile(las_n$Z, c(0.95, 0.99, 0.999), na.rm = TRUE)
quantile(las$Z, c(0.95, 0.99, 0.999), na.rm = TRUE)
chm_p2r <- rasterize_canopy(las_n,
res = res(dtm)[1],  # Match DTM resolution
algorithm = p2r())
plot(chm)
plot(chm_p2r)
chm_p2r <- resample(chm_p2r, dtm, method = "near")
plot(chm_p2r)
View(chm_p2r)
#Set No data values based on las file pulse count.
point_density <- rasterize_density(las, res = res(dtm)[1])
chm_p2r[point_density == 0] <- NA
point_density <- resample(point_density, chm_p2r, method = "near")
chm_p2r[point_density == 0] <- NA
writeRaster(chm_p2r, "F:/MASTERS/THESIS/2026_fresh/CHM/Patuxent_2013_chm_p2r.tif", overwrite = TRUE)
plot(point_density)
### Pitfree algorithm ---- ####
chm_pit <- rasterize_canopy(las_n,
res = res(dtm)[1],  # Match DTM resolution
algorithm = pitfree())
plot(chm_p2r)
plot(chm_pit)
chm_pit <- resample(chm_pit, dtm, method = "bilinear")
plot(chm_pit)
#Set No data values based on las file pulse count.
point_density <- rasterize_density(las, res = res(dtm)[1])
point_density <- resample(point_density, chm_pit, method = "near")
chm_pit[point_density == 0] <- NA
plot(chm_pit)
#Set No data values based on las file pulse count.
point_density <- rasterize_density(las_n, res = res(dtm)[1])
point_density <- resample(point_density, chm_pit, method = "near")
chm_pit[point_density == 0] <- NA
plot(chm_pit)
### Pitfree algorithm ---- ####
chm_pit <- rasterize_canopy(las_n,
res = res(dtm)[1],  # Match DTM resolution
algorithm = pitfree())
plot(chm_pit)
chm_pit <- resample(chm_pit, dtm, method = "bilinear")
plot(chm_pit)
#Set No data values based on las file pulse count.
point_density <- rasterize_density(las_n, res = res(dtm)[1])
point_density <- resample(point_density, chm_pit, method = "near")
chm_pit[point_density == 0] <- NA
plot(chm_pit)
### Pitfree algorithm ---- ####
chm_pit <- rasterize_canopy(las_n,
res = res(dtm)[1],  # Match DTM resolution
algorithm = pitfree())
#Set No data values based on las file pulse count.
point_density <- rasterize_density(las_n, chm_pit_re)
chm_pit_re <- resample(chm_pit, dtm, method = "bilinear")
plot(chm_pit)
#Set No data values based on las file pulse count.
point_density <- rasterize_density(las_n, chm_pit_re)
chm_pit_re[point_density == 0] <- NA
plot(point_density)
plot(chm_pit_re)
plot(point_density)
chm_pit_re[point_density == 0.5] <- NA
plot(chm_pit_re)
chm_pit_re[point_density == 1] <- NA
plot(chm_pit_re)
chm_pit_re[point_density == 10] <- NA
plot(chm_pit_re)
chm_pit_re <- resample(chm_pit, dtm, method = "bilinear")
plot(chm_pit_re)
writeRaster(chm_pit_re, "F:/MASTERS/THESIS/2026_fresh/CHM/Patuxent_2013_chm_pit.tif", overwrite = TRUE)
### dsmTIN algorithm ---- ####
chm_tin <- rasterize_canopy(las_norm,
res = res(dtm)[1],
algorithm = dsmtin())
### dsmTIN algorithm ---- ####
chm_tin <- rasterize_canopy(las_n,
res = res(dtm)[1],
algorithm = dsmtin())
plot(chm_tin)
chm_tin_re <- resample(chm_tin, dtm, method = "bilinear")
plot(chm_tin_re)
writeRaster(chm_tin_re, "F:/MASTERS/THESIS/2026_fresh/CHM/Patuxent_2013_chm_tin.tif", overwrite = TRUE)
### investigate chm algorithms ---- ####
difference <- chm_pit_re - chm_tin_re
plot(difference, main = "Difference: Pitfree - TIN")
# Load your rasters
rast1 <- rast("F:/MASTERS/THESIS/2026_fresh/DTM/PatuxentTerrain.tif")
rast2 <- rast("F:/MASTERS/THESIS/MD_HECRAS/pax/IQ50/Velocity (Max).PaxTerrain.tif")
# Check resolution
res(rast1)  # Returns c(x_resolution, y_resolution)
res(rast2)
# Compare if resolutions are the same
identical(res(rast1), res(rast2))
# Check if grids align (same resolution AND same origin)
compareGeom(rast1, rast2, stopOnError = FALSE)
chm <- rasterize_canopy(las_n,
res = res(dtm)[1],
algorithm = pitfree(
thresholds = c(0, 6.6, 16.4, 32.8, 49.2, 65.6),
max_edge = c(0, 2.5)))
#Align grids
chm <- resample(chm, dtm, method = "bilinear")
chm[chm < 0] <- 0
writeRaster(chm, "F:/MASTERS/THESIS/2026_fresh/CHM/Patuxent_2013_chm_pf_t1.tif", overwrite = TRUE)
# Focal smoothing
chm_final <- focal(chm, w = 3, fun = mean, na.rm = TRUE)
writeRaster(chm_final, "F:/MASTERS/THESIS/2026_fresh/CHM/Patuxent_2013_chm_pf_t2.tif", overwrite = TRUE)
library(pacman)
p_load(lidR, terra, ggplot2)
## PATUXENT 2013----
# 1) Read the point cloud and DTM
las <- readLAS("F:/MASTERS/THESIS/2026_fresh/Clipped_Lidar/Montgomery2013a.laz")   # or .las
dtm <- rast("F:/MASTERS/THESIS/2026_fresh/DTM/PatuxentTerrain.tif")
#Grab las point density
summary(las)
# Ensure CRS matches
crs(dtm)
#Looks like the crs of the dtm is Maryland State Plane (SPCS) on NAD83(NSRS2007) in US survey feet, a Lambert Conformal Conic (2SP) projection. The matching EPSG is EPSG:3582 (“NAD83 (NSRS2007) / Maryland (ftUS)”). The DTM is in WTK format, which las does not accept.
crs(las)
# Tell lidR the projection using EPSG (preferred for LAS headers)
projection(las) <- "EPSG:3582"
# 2) Normalize heights above ground using the DTM
# This subtracts ground elevation from each point’s Z
las_n <- normalize_height(las, dtm)
#Check out height distribution of normalized data
summary(las_n@data$Z)
#Statistical outlier removal (SOR)
# Removes isolated points that are far from their neighbors
las_clean <- classify_noise(las_n, sor(k = 15, m = 3))
las_clean <- filter_poi(las_clean, Classification != 18)
plot(las_clean, color = "Z")
#double check tallest points
#We know that x and y are in ft, let's make sure z is in ft too.
#If 99.9th percentile ≈ 35, your Z is in meters.
#If 99.9th percentile ≈ 125, your Z is in feet.
quantile(las_clean$Z, c(0.95, 0.99, 0.999), na.rm = TRUE)
summary(las_clean@data$Z)
# Create a mask of valid DTM cells
dtm_mask <- !is.na(dtm)
# Clip point cloud to only areas with valid DTM
# Convert DTM mask to polygon
dtm_valid <- as.polygons(dtm_mask, values = TRUE)
dtm_valid <- dtm_valid[dtm_valid$lyr1 == 1, ]  # Keep only valid areas
# Clip las to this polygon
las_clipped <- clip_roi(las, dtm_valid)
# Convert SpatVector to sf
dtm_valid_sf <- st_as_sf(dtm_valid)
p_load(lidR, terra, ggplot2, sf)
# Convert SpatVector to sf
dtm_valid_sf <- st_as_sf(dtm_valid)
# Clip las to this polygon
las_clipped <- clip_roi(las, dtm_valid)
# Clip las to this polygon
las_clipped <- clip_roi(las, dtm_sf)
# Convert SpatVector to sf
dtm_sf <- st_as_sf(dtm_valid)
# Clip las to this polygon
las_clipped <- clip_roi(las, dtm_sf)
# Ensure CRS matches
crs(dtm)
# Get CRS from las and assign it to the sf object
las_crs <- st_crs(las)
st_crs(dtm_sf) <- las_crs
# Clip las to this polygon
las_clipped <- clip_roi(las, dtm_sf)
crs(dtm_valid)
crs(las)
# Tell lidR the projection using EPSG (preferred for LAS headers)
projection(las) <- "EPSG:3582"
crs(las)
las <- readLAS("F:/MASTERS/THESIS/2026_fresh/Clipped_Lidar/Montgomery2013a.laz")   # or .las
dtm <- rast("F:/MASTERS/THESIS/2026_fresh/DTM/PatuxentTerrain.tif")
#Grab las point density
summary(las)
#density: 0.22 points/us-ft²
# Ensure CRS matches
crs(dtm)
#Looks like the crs of the dtm is Maryland State Plane (SPCS) on NAD83(NSRS2007) in US survey feet, a Lambert Conformal Conic (2SP) projection. The matching EPSG is EPSG:3582 (“NAD83 (NSRS2007) / Maryland (ftUS)”). The DTM is in WTK format, which las does not accept.
crs(las)
#Looks like the crs of the las file is Maryland State Plane (SPCS) on NAD83(NSRS2007) using Lambert Conformal Conic (2SP) and US survey feet for the axes. Same as the DTM! I found this out by bringing the pt cloud into QGIS and....guessing!
# Tell lidR the projection using EPSG (preferred for LAS headers)
projection(las) <- "EPSG:3582"
# 2) Normalize heights above ground using the DTM
# This subtracts ground elevation from each point’s Z
las_n <- normalize_height(las, dtm)
#Filter Method 2: Statistical outlier removal (SOR)
# Removes isolated points that are far from their neighbors
las_clean <- classify_noise(las_n, sor(k = 15, m = 3))
las_clean <- filter_poi(las_clean, Classification != 18)
#Remove points that couldn't be normalized
las_clean <- filter_poi(las_clean, !is.na(Z))
#double check tallest points
#We know that x and y are in ft, let's make sure z is in ft too.
#If 99.9th percentile ≈ 35, your Z is in meters.
#If 99.9th percentile ≈ 125, your Z is in feet.
quantile(las_clean$Z, c(0.95, 0.99, 0.999), na.rm = TRUE)
# Create CHM, remembering that x and y and z are different units.
chm <- rasterize_canopy(las_norm,
res = res(dtm)[1],
algorithm = pitfree(
thresholds = c(0, 6.6, 16.4, 32.8, 49.2, 65.6),
max_edge = c(0, 2.5)))
# Create CHM, remembering that x and y and z are different units.
chm <- rasterize_canopy(las_clean,
res = res(dtm)[1],
algorithm = pitfree(
thresholds = c(0, 6.6, 16.4, 32.8, 49.2, 65.6),
max_edge = c(0, 2.5)))
plot(chm)
